problem: https://leetcode.com/problems/longest-balanced-subarray-ii/description/?envType=daily-question&envId=2026-02-11

solution:
class SegmentTree {
public:
    int n, size;
    vector<int> sum, mn, mx;

    SegmentTree(int n_) : n(n_), size(4 * n_), sum(size, 0), mn(size, 0), mx(size, 0) {}

    void _pull(int node) {
        int l = node * 2, r = node * 2 + 1;

        sum[node] = sum[l] + sum[r];
        mn[node] = std::min(mn[l], sum[l] + mn[r]);
        mx[node] = std::max(mx[l], sum[l] + mx[r]);
    }

    void update(int idx, int val) {
        int node = 1, l = 0, r = n - 1;
        vector<int> path;

        while (l != r) {
            path.push_back(node);
            int m = l + (r - l) / 2;
            if (idx <= m) {
                node = node * 2;
                r = m;
            } else {
                node = node * 2 + 1;
                l = m + 1;
            }
        }

        sum[node] = val;
        mn[node] = val;
        mx[node] = val;

        while (!path.empty()) {
            _pull(path.back());
            path.pop_back();
        }
    }

    int find_rightmost_prefix(int target = 0) {
        int node = 1, l = 0, r = n - 1, sum_before = 0;

        auto _exist = [&](int node_, int sum_before_) -> bool {
            return mn[node_] <= target - sum_before_ && target - sum_before_ <= mx[node_];
        };

        if (!_exist(node, sum_before))
            return -1;

        while (l != r) {
            int m = l + (r - l) / 2;
            int lchild = node * 2, rchild = node * 2 + 1;

            int sum_before_right = sum[lchild] + sum_before;
            if (_exist(rchild, sum_before_right)) {
                node = rchild;
                l = m + 1;
                sum_before = sum_before_right;
            } else {
                node = lchild;
                r = m;
            }
        }

        return l;
    }
};

class Solution {
public:
    int longestBalanced(vector<int>& nums) {
        int n = nums.size(), result = 0;

        SegmentTree segTree(n);
        unordered_map<int, int> first;

        for (int l = n - 1; l >= 0; --l) {
            int num = nums[l];

            auto it = first.find(num);
            if (it != first.end())
                segTree.update(it->second, 0);

            first[num] = l;
            segTree.update(l, (num % 2 == 0) ? 1 : -1);

            int r = segTree.find_rightmost_prefix(0);
            if (r >= l)
                result = std::max(result, r - l + 1);
        }

        return result;
    }
};
