problem: https://leetcode.com/problems/maximum-profit-from-trading-stocks-with-discounts/description/?envType=daily-question&envId=2025-12-16

solution:
class Solution {
private:
    void dfs(int u, vector<int>& present, vector<int>& future, vector<vector<int>>& tree, vector<vector<vector<int>>>& dp, int budget){
        vector<pair<vector<int>, vector<int> >> childDPs;
        for(int v : tree[u]){
            dfs(v, present, future, tree, dp, budget);
            childDPs.emplace_back(dp[v][0], dp[v][1]);
        }

        for(int parentBought=0; parentBought <= 1; parentBought++){
            int price = parentBought ? present[u] / 2 : present[u];
            int profit = future[u] - price;
            vector<int> curr(budget+1, 0);

            vector<int>base(budget+1, 0);
            for(auto& child : childDPs){
                vector<int> next(budget+1, 0);
                for(int i=0; i<=budget; i++) {
                    if(base[i] == 0 && i != 0) continue;
                    for(int j=0; i+j <= budget; j++) next[i+j] = max(next[i+j], base[i] + child.first[j]);
                }
                base = next;
            }

            for(int b=0; b<=budget; b++) curr[b] = max(curr[b], base[b]);

            if(price <= budget){
                vector<int> baseBuy(budget+1, 0);
                for(auto& child : childDPs) {
                    vector<int> next(budget+1, 0);
                    for(int i=0; i<=budget; i++){
                        if(baseBuy[i] == 0 && i != 0) continue;
                        for(int j=0; i+j<=budget; j++) next[i+j] = max(next[i+j], baseBuy[i] + child.second[j]);
                    }
                    baseBuy = next;
                }

                for(int b=price; b<=budget; b++) curr[b] = max(curr[b], baseBuy[b-price] + profit);
            }

            dp[u][parentBought] = curr;
        }
    };

public:
    int maxProfit(int n, vector<int>& present, vector<int>& future, vector<vector<int>>& hierarchy, int budget) {
        vector<vector<int>> tree(n);
        for(auto& edge : hierarchy) tree[edge[0]-1].push_back(edge[1]-1);

        vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(budget+1, 0)));
        dfs(0, present, future, tree, dp, budget);
        int res = 0;
        for(int i=0; i<=budget; i++) res = max(res, dp[0][0][i]);
        return res;
    }
};
